<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>RTSS functions listed by category</title>
</head>
<body bgcolor="#FFFFFF">
<center>Scilab functions - by category</center>
<div align="right">Last update : 15/09/2009</div>
<p><b>RTSS functions listed by category</b> - Browse the RTSS functions by category</p>
<h3><font color="blue">Homogeneous Transforms</font></h3>
<dl><dd>
<b></b><dd>
<li>
<a href="rt_eul2tr.htm"><b>rt_eul2tr</b></a>: Euler angles to homogeneous transform</li>
<li>
<a href="rt_oa2tr.htm"><b>rt_oa2tr</b></a>: orientation and approach vector to homogeneous transform</li>
<li>
<a href="rt_rotvec.htm"><b>rt_rotvec</b></a>: rotation about arbitrary axis</li>
<li>
<a href="rt_rotx.htm"><b>rt_rotx</b></a>: homogeneous transform for rotation about X-axis</li>
<li>
<a href="rt_roty.htm"><b>rt_roty</b></a>: homogeneous transform for rotation about Y-axis</li>
<li>
<a href="rt_rotz.htm"><b>rt_rotz</b></a>: homogeneous transform for rotation about Z-axis</li>
<li>
<a href="rt_rpy2tr.htm"><b>rt_rpy2tr</b></a>: Roll/pitch/yaw angles to homogeneous transform</li>
<li>
<a href="rt_tr2eul.htm"><b>rt_tr2eul</b></a>: homogeneous transform to Euler angles</li>
<li>
<a href="rt_tr2rot.htm"><b>rt_tr2rot</b></a>: homogeneous transform to rotation submatrix</li>
<li>
<a href="rt_tr2rpy.htm"><b>rt_tr2rpy</b></a>: homogeneous transform to roll/pitch/yaw angles</li>
<li>
<a href="rt_transl.htm"><b>rt_transl</b></a>: set or extract the translational component of a homogeneous transform</li>
<li>
<a href="rt_trnorm.htm"><b>rt_trnorm</b></a>: normalize a homogeneous transform</li>
</dd>
</dd></dl>
<h3><font color="blue">Quaternions</font></h3>
<dl><dd>
<b></b><dd>
<li>
<a href="rt_quaternion.htm"><b>disp</b></a>: displays the quaternion as one-line summary of its coefficients</li>
<li>
<a href="rt_quaternion.htm"><b>double</b></a>: convert a quaternion object to a 4-element vector</li>
<li>
<a href="rt_quaternion.htm"><b>hat</b></a>: (^) raise quaternion to integer power</li>
<li>
<a href="rt_quaternion.htm"><b>inv</b></a>: invert a quaternion</li>
<li>
<a href="rt_quaternion.htm"><b>norm</b></a>: norm of a quaternion</li>
<li>
<a href="rt_plot-quaternion.htm"><b>rt_plot</b></a>: display a quaternion as a 3D rotation</li>
<li>
<a href="rt_quaternion.htm"><b>rt_q2tr</b></a>: quaternion to homogeneous transform</li>
<li>
<a href="rt_qinterp.htm"><b>rt_qinterp</b></a>: interpolate unit-quaternions</li>
<li>
<a href="rt_quaternion.htm"><b>rt_quaternion</b></a>: construct/clone a quaternion object</li>
<li>
<a href="rt_quaternion.htm"><b>rt_unit</b></a>: unitize a quaternion</li>
<li>
<a href="rt_quaternion.htm"><b>slash</b></a>: (/) divide quaternion by quaternion or scalar</li>
<li>
<a href="rt_quaternion.htm"><b>star</b></a>: (*) multiply quaternion by quaternion or vector</li>
</dd>
</dd></dl>
<h3><font color="blue">Kinematics</font></h3>
<dl><dd>
<b></b><dd>
<li>
<a href="rt_diff2tr.htm"><b>rt_diff2tr</b></a>: convert a differential motion vector to a homogeneous transform</li>
<li>
<a href="rt_fkine.htm"><b>rt_fkine</b></a>: compute the forward kinematics for a serial n-link manipulator</li>
<li>
<a href="rt_ikine.htm"><b>rt_ikine</b></a>: compute the inverse kinematics for a generic serial n-link manipulator</li>
<li>
<a href="rt_ikine560.htm"><b>rt_ikine560</b></a>: compute the inverse kinematics for a Puma 560 like robot arm</li>
<li>
<a href="rt_ikine560paul.htm"><b>rt_ikine560paul</b></a>: compute all solutions for the inverse kinematics of a Puma 560 like robot arm using the Paul's algebraic method</li>
<li>
<a href="rt_ikinestanfpaul.htm"><b>rt_ikinestanfpaul</b></a>: compute all solutions for the inverse kinematics of a Stanford like robot arm using the Paul's algebraic method</li>
<li>
<a href="rt_jacob0.htm"><b>rt_jacob0</b></a>: compute manipulator Jacobian in base coordinate frame</li>
<li>
<a href="rt_jacobn.htm"><b>rt_jacobn</b></a>: compute manipulator Jacobian in end-effector coordinate frame</li>
<li>
<a href="rt_tr2diff.htm"><b>rt_tr2diff</b></a>: convert a homogeneous transform to a differential motion vector</li>
<li>
<a href="rt_tr2jac.htm"><b>rt_tr2jac</b></a>: compute a Jacobian to map differential motion between frames</li>
</dd>
</dd></dl>
<h3><font color="blue">Dynamics</font></h3>
<dl><dd>
<b></b><dd>
<li>
<a href="rt_accel.htm"><b>rt_accel</b></a>: compute manipulator forward dynamics</li>
<li>
<a href="rt_cinertia.htm"><b>rt_cinertia</b></a>: compute the Cartesian (operational space) manipulator inertia matrix</li>
<li>
<a href="rt_coriolis.htm"><b>rt_coriolis</b></a>: compute the manipulator Coriolis/centripetal torque components</li>
<li>
<a href="rt_fdyn.htm"><b>rt_fdyn</b></a>: integrate the forward dynamics</li>
<li>
<a href="rt_friction-link.htm"><b>rt_friction</b></a>: compute joint friction torque</li>
<li>
<a href="rt_frne.htm"><b>rt_frne</b></a>: fast rne. C version of algorithm that computes inverse dynamics via recursive Newton-Euler formulation</li>
<li>
<a href="rt_ftrans.htm"><b>rt_ftrans</b></a>: transform force/moment between coordinate frames</li>
<li>
<a href="rt_gravload.htm"><b>rt_gravload</b></a>: compute the manipulator gravity torque components</li>
<li>
<a href="rt_inertia.htm"><b>rt_inertia</b></a>: compute the manipulator joint-space inertia matrix</li>
<li>
<a href="rt_itorque.htm"><b>rt_itorque</b></a>: compute the manipulator inertia torque component</li>
<li>
<a href="rt_rne.htm"><b>rt_rne</b></a>: compute inverse dynamics via recursive Newton-Euler formulation</li>
</dd>
</dd></dl>
<h3><font color="blue">Manipulator Models</font></h3>
<dl><dd>
<b></b><dd>
<li>
<a href="rt_link.htm"><b>rt_link</b></a>: construct/clone a link object</li>
<li>
<a href="rt_nofriction-robot.htm"><b>rt_nofriction</b></a>: remove friction from a robot object</li>
<li>
<a href="rt_perturb.htm"><b>rt_perturb</b></a>: randomly modify some dynamic parameters</li>
<li>
<a href="rt_puma560.htm"><b>rt_puma560</b></a>: create a Puma 560 robot object</li>
<li>
<a href="rt_puma560akb.htm"><b>rt_puma560akb</b></a>: create a Puma 560 robot object using the Armstrong, Khatib and Burdick kinematic notation</li>
<li>
<a href="rt_robot.htm"><b>rt_robot</b></a>: construct/clone a robot object</li>
<li>
<a href="rt_showlink.htm"><b>rt_showlink</b></a>: show link/robot data in detail</li>
<li>
<a href="rt_stanford.htm"><b>rt_stanford</b></a>: create a Stanford manipulator robot object</li>
<li>
<a href="rt_twolink.htm"><b>rt_twolink</b></a>: load kinematic and dynamic data for a simple 2-link RR planar</li>
<li>
<a href="rt_robot.htm"><b>star</b></a>: (*) construct a robot which is the series connection of the multiplicands</li>
</dd>
</dd></dl>
<h3><font color="blue">Trajectory Generation</font></h3>
<dl><dd>
<b></b><dd>
<li>
<a href="rt_ctraj.htm"><b>rt_ctraj</b></a>: compute a Cartesian trajectory between two points</li>
<li>
<a href="rt_jtraj.htm"><b>rt_jtraj</b></a>: compute a joint space trajectory between two joint coordinates poses</li>
<li>
<a href="rt_trinterp.htm"><b>rt_trinterp</b></a>: interpolate homogeneous transforms</li>
</dd>
</dd></dl>
<h3><font color="blue">Graphics</font></h3>
<dl><dd>
<b></b><dd>
<li>
<a href="rt_drivebot.htm"><b>rt_drivebot</b></a>: drive a graphical robot</li>
<li>
<a href="rt_plot-robot.htm"><b>rt_plot</b></a>: create a graphical animation for a robot object</li>
</dd>
</dd></dl>
<h3><font color="blue">Other</font></h3>
<dl><dd>
<b></b><dd>
<li>
<a href="rt_ishomog.htm"><b>rt_ishomog</b></a>: test if argument is a homogeneous transformation</li>
<li>
<a href="rt_maniplty.htm"><b>rt_maniplty</b></a>: compute the scalar manipulability index for the manipulator at the given pose</li>
<li>
<a href="rt_unit.htm"><b>rt_unit</b></a>: unitize a vector</li>
</dd>
</dd></dl>
</body>
</html>
